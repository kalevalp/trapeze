\documentclass{article}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage[margin=2cm]{geometry}

\newcommand{\store}{\Delta}
\newcommand{\storeupdate}[3]{#1[#2\,{:}{=}\,#3]}
\newcommand{\storeaccess}[2]{#1(#2)}
\newcommand{\indomain}[2]{#1\in\text{\textsf{dom}}(#2)}
\newcommand{\notindomain}[2]{#1\notin\text{\textsf{dom}}(#2)}

\newcommand{\facet}[3]{\langle#1\,{?}\,#2\,{:}\,#3\rangle}
\newcommand{\ffacet}[3]{\langle\!\facet{#1}{#2}{#3}\!\rangle}
\newcommand{\splits}[4]{(\!\!\facet{\genfrac{}{}{0pt}{1}{#1}{#2}}{#3}{#4}\!\!)}

\newlength{\longrightarrowlength}
\settowidth{\longrightarrowlength}{$\longrightarrow$}
\newlength{\notlength}
\settowidth{\notlength}{$\not$}

\newcommand{\startrules}{\begin{array}{l@{lcl@{l|ll}}
\newcommand{\finishrules}{\end{array}}
\newcommand{\rn}[1]{\text{\textsc{[#1]}}}
\newcommand{\mrule}[3]{%
      \multicolumn{6}{c}{
        \dfrac{
          \begin{array}{c}
            #2
          \end{array}
        }{#3}
      }
    &
      \rn{#1}
  \\
      \multicolumn{7}{c}{}
  \\%
}
\newcommand{\steprule}[5]{%
      \multicolumn{2}{l}{ #3 }
    &
      {#4}
    &
      \multicolumn{2}{l|}{ #5 }
    &
      #2
    &
      \rn{#1}
  \\%
}
\newcommand{\tsteparrow}[1]{\overset{#1}{\longrightarrow}}
\newcommand{\tstep}[3]{#2\tsteparrow{#1}#3}
\newcommand{\tsteprule}[5]{\steprule{#1}{#2}{#4}{\tsteparrow{#3}}{#5}}
\newcommand{\ssteparrow}[1]{\overset{#1}{\longrightarrow}}
\newcommand{\ssteparrowstar}[1]{\overset{#1}{\longrightarrow^*}}
\newcommand{\sstep}[3]{#2\ssteparrow{#1}#3}
\newcommand{\sstepstar}[3]{#2\ssteparrowstar{#1}#3}
\newcommand{\ssteprule}[5]{\steprule{#1}{#2}{#4}{\ssteparrow{#3}}{#5}}
\newcommand{\ltsteparrow}[2]{\overset{#2}{\underset{#1}{\longrightarrow}}}
\newcommand{\ltstep}[4]{#3\ltsteparrow{#1}{#2}#4}
\newcommand{\ltsteprule}[6]{\steprule{#1}{#2}{#5}{\ltsteparrow{#3}{#4}}{#6}}
\newcommand{\lssteparrow}[2]{\overset{#2}{\underset{#1}{\longrightarrow}}}
\newcommand{\lsstep}[4]{#3\lssteparrow{#1}{#2}#4}
\newcommand{\lssteprule}[6]{\steprule{#1}{#2}{#5}{\lssteparrow{#3}{#4}}{#6}}

\newcommand{\hole}{{\bullet}}
\newcommand{\hash}[2]{\##1\,{:}{=}\,#2}
\newcommand{\replace}[3]{\storeupdate{#1}{#2}{#3}}
\newcommand{\upd}[3]{\replace{#1}{#2}{#3}}
\newcommand{\ret}[1]{\text{\textsf{return}}#1}
\newcommand{\bindIO}[2]{%
  #1\,
  \overset{\text{\texttt{IO}}}
    {{>}\!\!{>}\!{=}}
  \,#2
  %
}
\newcommand{\bind}[2]{%
  #1\,
  \overset{\text{\texttt{FIO}}}
    {{>}\!\!{>}\!{=}}
  \,#2
  %
}
\newcommand{\newref}[1]{\text{\textsf{new}}#1}
\newcommand{\readref}[1]{\text{\textsf{read}}#1}
\newcommand{\writeref}[2]{\text{\textsf{write}}#1#2}
\newcommand{\Raw}[1]{\text{\textsf{Raw}}#1}
\newcommand{\bindFac}[2]{\text{\textsf{BindFac}}#1#2}
%\newcommand{\bindFac}[2]{%
%  #1\,
%  \overset{\text{\texttt{Fac}}}
%    {{>}\!\!{>}\!{=}}
%  \,#2
%  %
%}
\newcommand{\prodd}[1]{\text{\textsf{runFacFIO}}#1}
\newcommand{\threads}[3]{\,[\!\!\!\ffacet{#1}{#2}{#3}\!\!\!]\,}
\newcommand{\yield}[2]{\text{\textsf{yield}}#1#2}
\newcommand{\readfile}[1]{\text{\textsf{get}}#1}
\newcommand{\readfilen}[2]{\text{\textsf{get}}#1#2}
\newcommand{\writefile}[2]{\text{\textsf{put}}#1#2}
\newcommand{\readevent}[2]{\text{\textsf{R}}(#1,#2)}
\newcommand{\writeevent}[2]{\text{\textsf{W}}(#1,#2)}
\newcommand{\notbr}[1]{\overline{#1}}
\newcommand{\concat}[2]{#1\,{{+}\!\!{+}}\,#2}

\newcommand{\letrec}[3]{\mu x{:}T.t}
\newcommand{\ifPositive}[3]{\text{\textsf{ifPositive $#1$ $#2$ $#3$}}}
\newcommand{\IntType}{\text{\textsf{Int}}}
\newcommand{\FacetedType}[1]{\text{\textsf{Faceted}}#1}
\newcommand{\FIOType}[1]{\text{\textsf{FIO}}#1}
\newcommand{\FIORefType}[1]{\text{\textsf{FIORef}}#1}
\newcommand{\agree}[2]{#2\vdash#1}
\newcommand{\stdize}[1]{\s{standardize}{#1}}

\newcommand{\s}[1]{\text{\textit{#1}}}

\newcommand{\startsyntax}{\begin{array}{rclrll}}
\newcommand{\sepsyntax}{\\&&&|&}
\newcommand{\finishsyntax}{\end{array}}

\newcommand{\thread}[2]{(#1,#2)}
\newcommand{\opread}[2]{\textsf{read}#1#2}
\newcommand{\opwrite}[3]{\textsf{write}#1#2#3}
\newcommand{\opsend}[3]{\textsf{send}#1#2#3}
\newcommand{\opfork}[2]{\textsf{fork}#1#2}
\newcommand{\opstuck}{\textsf{stuck}}
\newcommand{\opraiselabel}[2]{\textsf{raiseLabel}#1#2}
\newcommand{\evstart}[1]{\textsf{start}#1}
\newcommand{\evsend}[2]{\textsf{output}#1#2}
\newcommand{\proj}[2]{#1{\downarrow_{#2}}}
\newcommand{\lequiv}[3]{#2\approx_{#1}#3}


\begin{document}


$\startsyntax
  l     & \in & \s{Label}  \\
  ch    & \in & \s{Channel}  \\
  &           & \s{label} & : & \s{Channel}\to\s{Label}  \\
  v     & \in & \s{Value}  \\
  S     & \in & \s{LabeledValueSet} & = & \multicolumn{2}{l}{2^{\s{Value}\times\s{Label}}}  \\
  k     & \in & \s{Key}  \\
  \sigma& \in & \s{Store} & = & \s{Key}\to\s{LabeledValueSet}  \\
  c     & \in & \s{Code}  \\
  t     & \in & \s{Thread} & ::= & \thread{c}{l}  \\
  ts    & \in & \s{Threads} & = & \text{multisets of threads}  \\
  f     & \in & \s{ReadContinuation} & = & \s{LabeledValueSet}\to\s{Code}  \\
  op    & \in & \s{Operation} & ::= &
      \opread{k}{f}
    \sepsyntax
      \opwrite{k}{v}{c}
    \sepsyntax
      \opsend{ch}{v}{c}
    \sepsyntax
      \opfork{c}{c}
    \sepsyntax
      \opraiselabel{l}{c}
    \sepsyntax
      \opstuck
    \\
  e     & \in & \s{Event} & ::= &
      \evstart{t}
    \sepsyntax
      \evsend{ch}{v}
    \sepsyntax
      \epsilon
    \\
  es    & \in & \s{Events} & = & \s{Event}^*  \\
  \Sigma& \in & \s{State} & ::= & (\sigma,ts)  \\
  &           & \s{run} & : & \s{Code}\to\s{Operation}  \\
  &           & \s{write} & : & \s{LabeledValueSet}\times\s{Value}\times\s{Label}\to\s{LabeledValueSet}  \\
  &           & \s{write}(S,v,l) & = & (S\setminus\{(v',l')\in S|l\sqsubseteq l'\})\cup\{(v,l)\}  \\
  &           & \proj{\hole}{\hole}
                  & : & \text{``Various things''}\to\s{Label}\to\text{``Various things''}  \\
  &           & \proj{S}{l} & = & \{(v,l')\in S|l'\sqsubseteq l\}  \\
  &           & \proj{ts}{l} & = & \text{multiset}\{\thread{c}{l'}\in ts|l'\sqsubseteq l\}  \\
  &           & \proj{\sigma}{l} & = & \lambda k. \proj{\sigma(k)}{l}  \\
  &           & \proj{e}{l} & = &
    \begin{cases}
      e  & \exists c,l'.e=\evstart{\thread{c}{l'}}\text{ and }l'\sqsubseteq l  \\
      e  & \exists ch,v.e=\evsend{ch}{v}\text{ and }\s{label}(ch)\sqsubseteq l  \\
      \epsilon & \text{otherwise.}
    \end{cases}  \\
  &           & \proj{(e_1\ldots e_n)}{l} & = & \proj{e_1}{l}\ldots\proj{e_n}{l}  \\
  &           & \proj{(\sigma,ts)}{l} & = & (\proj{\sigma}{l},\proj{ts}{l})   \\
  &           & \lequiv{l}{\hole_1}{\hole_2} & \text{means} & \proj{\hole_1}{l}=\proj{\hole_2}{l}  \\
\finishsyntax$
\\
\fbox{$\tstep{e}{(\sigma,t)}{\Sigma}$} Thread transition relation
\\
$\startrules
  \tsteprule{p-send}
        {\s{run}(c)=\opsend{ch}{v}{c'}\qquad l\sqsubseteq\s{label}(ch)}
        {\evsend{ch}{v}}
        {(\sigma,\thread{c}{l})}
        {(\sigma,\{\thread{c'}{l}\})}
  \tsteprule{p-read}
        {\s{run}(c)=\opread{k}{f}}
        {\epsilon}
        {(\sigma,\thread{c}{l})}
        {(\sigma,\{\thread{f(\proj{\sigma(k)}{l})}{l}\})}
  \tsteprule{p-write}
        {\s{run}(c)=\opwrite{k}{v}{c'}}
        {\epsilon}
        {(\sigma,\thread{c}{l})}
        {(\upd{\sigma}{k}{\s{write}(\sigma(k),v,l)},\{\thread{c'}{l}\})}
  \tsteprule{p-fork}
        {\s{run}(c) = \opfork{c_1}{c_2}}
        {\epsilon}
        {(\sigma,\thread{c}{l})}
        {(\sigma,\{\thread{c_1}{l},\thread{c_2}{l}\})}
  \tsteprule{p-raise-label}
        {\s{run}(c) = \opraiselabel{l'}{c'}\qquad l\sqsubseteq l'}
        {\epsilon}
        {(\sigma,\thread{c}{l})}
        {(\sigma,\{\thread{c'}{l'}\})}
\finishrules$
\\
\fbox{$\sstep{e}{\Sigma}{\Sigma}$} State transition relation
\\
$\startrules
  \ssteprule{s-start}
        {}
        {\evstart{t}}
        {(\sigma,ts)}
        {(\sigma,ts+t)}
  \ssteprule{s-skip}
        {}
        {\epsilon}
        {(\sigma,ts)}
        {(\sigma,ts)}
  \ssteprule{s-step}
        {\tstep{e}{(\sigma,\thread{c}{l})}{(\sigma',ts')}}
        {e}
        {(\sigma,ts\uplus\{\thread{c}{l}\})}
        {(\sigma',ts\uplus ts')}
\finishrules$
\\
\textbf{Theorem (Single step Progress Sensitive Non-Interference).}
\\
If $\lequiv{l}{\Sigma_1}{\Sigma_2}$
and $\sstep{e_1}{\Sigma_1}{\Sigma_1'}$,
\\
then $\exists \Sigma_2'.\exists e_2.\sstep{e_2}{\Sigma_2}{\Sigma_2'}$
and $\lequiv{l}{\Sigma_1'}{\Sigma_2'}$
and $\lequiv{l}{e_1}{e_2}$.
\\
\textit{Proof.}
Please continue reading below.
\\
\fbox{$\sstepstar{es}{\Sigma}{\Sigma}$} Multiple-step state transition relation
\\
$\startrules
  \mrule{refl}{
  }{
    \sstepstar{}{\Sigma}{\Sigma}
  }
  \mrule{trans}{
      \sstep{e}{\Sigma}{\Sigma'}
    \qquad
      \sstepstar{es}{\Sigma'}{\Sigma''}
  }{
    \sstepstar{ees}{\Sigma}{\Sigma''}
  }
\finishrules$
\\
\textbf{Corollary (Progress Sensitive Non-Interference).}
\\
If $\lequiv{l}{\Sigma_1}{\Sigma_2}$
and $\sstepstar{es_1}{\Sigma_1}{\Sigma_1'}$,
\\
then $\exists \Sigma_2'.\exists es_2.\sstepstar{es_2}{\Sigma_2}{\Sigma_2'}$
and $\lequiv{l}{\Sigma_1'}{\Sigma_2'}$
and $\lequiv{l}{es_1}{es_2}$.
\\
\textit{Proof.}
By induction on the derivation of $\sstepstar{es_1}{\Sigma_1}{\Sigma_1'}$.


\newpage
\noindent
%
%
\fbox{$\lsstep{l}{e}{\Sigma}{\Sigma}$} Projected state transition relation
\\
$\startrules
  \mrule{ps}{
      \sstep{e}{\Sigma_1}{\Sigma_2}
  }{
    \lsstep{l}{\proj{e}{l}}{\Sigma_1}{\proj{\Sigma_2}{l}}
  }
\finishrules$
\\
\textbf{Lemma (Invisibility).}
\\
If $l'\not\sqsubseteq l$
and $\tstep{e}{(\sigma,\thread{c}{l'})}{(\sigma',ts')}$,
\\
then $\proj{\sigma'}{l}=\proj{\sigma}{l}$
and $\proj{e}{l}=\epsilon$
and $\proj{ts'}{l}=\{\}$.
\\
\textit{Proof.}
Omitted.
\\
\textbf{Theorem (Projection 1).}
\\
\begin{tabular}{l@{$\qquad$}l}
  (1) & If $\sstep{e}{\Sigma}{\Sigma'}$,
\\
      & then $\lsstep{l}{\proj{e}{l}}{\proj{\Sigma}{l}}{\proj{\Sigma'}{l}}$.
\end{tabular}
\\
\textit{Proof.}
\\
\newcommand{\z}{$\quad$}
\begin{tabular}{l@{$\qquad$}l@{$\qquad$}l}
        & Let $(\sigma, ts) = \Sigma$.
\\
        & Let $(\sigma', ts') = \Sigma'$.
\\
        & Proceed by cases (ie inversion) on (1).
\\
        & Case: $\rn{s-start}$. Let $c,l'$ be such that:
\\
        & \z $e=\evstart{\thread{c}{l'}}$; and
\\
        & \z $\sigma'=\sigma$; and
\\
        & \z $ts'=ts+\thread{c}{l'}$.
\\
        & \z Proceed by cases.
\\
        & \z Case: where $l'\sqsubseteq l$.
\\
        & \z \z $\sstep{\evstart{\thread{c}{l'}}}{\proj{\Sigma}{l}}{(\proj{\sigma}{l},\proj{ts}{l}+\thread{c}{l'})}$
        & by  $\rn{s-start}$.
\\
        & \z \z QED
        & by  $\rn{ps}$.
\\
       & \z Case: where $l'\not\sqsubseteq l$.
\\
        & \z \z $\sstep{\epsilon}{\proj{\Sigma}{l}}{\proj{\Sigma}{l}}$
        & by  $\rn{s-skip}$.
\\
        & \z \z QED
        & by  $\rn{ps}$.
\\
        & Case: $\rn{s-skip}$. $e=\epsilon$ and $\Sigma'=\Sigma$.
\\
        & \z $\sstep{\epsilon}{\proj{\Sigma}{l}}{\proj{\Sigma}{l}}$
        & by  $\rn{s-skip}$.
\\
        & \z QED
        & by  $\rn{ps}$.
\\
        & Last case: $\rn{s-step}$. Let $c,l',ts_1,ts_2$ be such that:
\\
        & $ts=ts_1+\thread{c}{l'}$; and
\\
        & $ts'=ts_1\uplus ts_2$; and
\\
  (2)   & $\tstep{e}{(\sigma,\thread{c}{l'})}{(\sigma',ts_2)}$.
\\
        & Proceed by cases.
\\
        & Case: where $l'\not\sqsubseteq l$.
\\
        & \z $\proj{\sigma'}{l}=\proj{\sigma}{l}$ and $\proj{e}{l}=\epsilon$ and $\proj{ts_2}{l}=\{\}$
        & by Invisibility.
\\
        & \z QED
        & by  $\rn{ps}$ and $\rn{s-skip}$.
\\
        & Last case: where $l'\sqsubseteq l$.
\\
        & Proceed by cases (ie inversion) on (2).
\\
        & Case: $\rn{p-send}$. Let $ch,v,c'$ be such that:
\\
        & \z $e=\evsend{ch}{v}$; and
\\
        & \z $\sigma'=\sigma$; and
\\
        & \z $ts_2=\{\thread{c'}{l'}\}$; and
\\
        & \z $run(c)=\opsend{ch}{v}{c'}$; and
\\
        & \z $l'\sqsubseteq\s{label}(ch)$.
\\
        & \z $\tstep{\evsend{ch}{v}}{(\proj{\sigma}{l},\thread{c}{l'})}{(\proj{\sigma}{l},\{\thread{c'}{l'}\})}$
        & by $\rn{p-send}$.
\\
        & \z $\sstep{\evsend{ch}{v}}{\proj{\Sigma}{l}}{(\proj{\sigma}{l},\proj{ts_1}{l}+\thread{c'}{l'})}$
        & by $\rn{s-step}$.
\\
        & \z QED
        & by $\rn{ps}$.
\\
        & Remaining cases omitted.
\end{tabular}


\newpage
\noindent
%
%
\textbf{Theorem (Projection 2).}
\\
\begin{tabular}{l@{$\qquad$}l}
  (1) & If $\lsstep{l}{e_1}{\proj{\Sigma}{l}}{\Sigma_1}$,
\\
      & then $\exists \Sigma_2.\exists e_2.\sstep{e_2}{\Sigma}{\Sigma_2}$
        and $\Sigma_1 = \proj{\Sigma_2}{l}$
        and $e_1 = \proj{e_2}{l}$.
\end{tabular}
\\
\textit{Proof.}
\\
\begin{tabular}{l@{$\qquad$}l@{\qquad}l}
        & Let $e',\Sigma'$ be such that:
        & (by inversion on (1))
\\
  (2)   & $\sstep{e'}{\proj{\Sigma}{l}}{\Sigma'}$; and
\\
        & $e_1=\proj{e'}{l}$; and
\\
        & $\Sigma_1=\proj{\Sigma'}{l}$.
\\
        & Let $(\sigma,ts)=\Sigma$.
\\
        & Let $(\sigma',ts')=\Sigma'$.
\\
        & Proceed by cases (ie inversion) on (2).
\\
        & Case: $\rn{s-start}$. Let $c,l'$ be such that:
\\
        & \z $e'=\thread{c}{l'}$; and
\\
        & \z $\sigma'=\proj{\sigma}{l}$; and
\\
        & \z $ts'=\proj{ts}{l}+\thread{c}{l'}$; and
\\
        & \z Pick $\Sigma_2 = (\sigma,ts+\thread{c}{l'})$ and $e_2=e'$.
\\
        & \z QED
        & by $\rn{s-start}$.
\\
        & Case: $\rn{s-skip}$.
\\
        & \z Pick $\Sigma_2=\Sigma$ and $e_2=\epsilon$.
\\
        & \z QED
        & by $\rn{s-skip}$.
\\
        & Last case: $\rn{s-step}$. Let $c,l',ts_3,ts_4$ be such that:
\\
  (3)   & $\proj{ts}{l}=ts_3+\thread{c}{l'}$; and
\\
        & $ts'=ts_3\uplus ts_4$; and
\\
  (4)   & $\tstep{e'}{(\proj{\sigma}{l},\thread{c}{l'})}{(\sigma',ts_4)}$.
\\
        & $l'\sqsubseteq l$
        & by (3).
\\
        & $t_3 = \proj{(ts-\thread{c}{l'})}{l}$
        & by (3).
\\
        & Proceed by cases (ie inversion) on (4).
\\
        & Case: $\rn{p-send}$. Let $ch,v,c'$ be such that:
\\
        & \z $e'=\evsend{ch}{v}$; and
\\
        & \z $\sigma'=\proj{\sigma}{l}$; and
\\
        & \z $ts_4=\{\thread{c'}{l'}\}$; and
\\
        & \z $run(c)=\opsend{ch}{v}{c'}$; and
\\
        & \z $l'\sqsubseteq\s{label}(ch)$.
\\
        & \z Pick $\Sigma_2 = (\sigma, ts-\thread{c}{l'}+\thread{c'}{l'})$ and $e_2=e'$.
\\
        & \z QED
        & by $\rn{p-send}$.
\\
        & Remaining cases omitted.
\end{tabular}
\\
\textbf{Theorem (TSNI).}
\\
\begin{tabular}{l@{$\qquad$}l}
  (1) & If $\lequiv{l}{\Sigma_1}{\Sigma_2}$
\\
  (2) & and $\sstep{e_1}{\Sigma_1}{\Sigma_1'}$,
\\
      & then $\exists \Sigma_2'.\exists e_2.\sstep{e_2}{\Sigma_2}{\Sigma_2'}$
        and $\lequiv{l}{\Sigma_1'}{\Sigma_2'}$
        and $\lequiv{l}{e_1}{e_2}$.
\end{tabular}
\\
\textit{Proof.}
\\
\begin{tabular}{l@{$\qquad$}l@{\qquad}l}
  (3) & $\lsstep{l}{\proj{e_1}{l}}{\proj{\Sigma_1}{l}}{\proj{\Sigma_1'}{l}}$
      & by applying Projection 1 to (2).
\\
  (4) & $\lsstep{l}{\proj{e_1}{l}}{\proj{\Sigma_2}{l}}{\proj{\Sigma_1'}{l}}$
      & by substituting (1) in (3).
\\
      & QED
      & by applying Projection 2 to (4).
\end{tabular}


\end{document}
