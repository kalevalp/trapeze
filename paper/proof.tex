\section{Proof semantics}

\newcommand{\store}{\Delta}
\newcommand{\storeupdate}[3]{#1[#2\,{:}{=}\,#3]}
\newcommand{\storeaccess}[2]{#1(#2)}
\newcommand{\indomain}[2]{#1\in\text{\textsf{dom}}(#2)}
\newcommand{\notindomain}[2]{#1\notin\text{\textsf{dom}}(#2)}

\newcommand{\facet}[3]{\langle#1\,{?}\,#2\,{:}\,#3\rangle}
\newcommand{\ffacet}[3]{\langle\!\facet{#1}{#2}{#3}\!\rangle}
\newcommand{\splits}[4]{(\!\!\facet{\genfrac{}{}{0pt}{1}{#1}{#2}}{#3}{#4}\!\!)}

\newlength{\longrightarrowlength}
\settowidth{\longrightarrowlength}{$\longrightarrow$}
\newlength{\notlength}
\settowidth{\notlength}{$\not$}

\newcommand{\startrules}{\begin{array}{l@{lcl@{l|ll}}
\newcommand{\finishrules}{\end{array}}
\newcommand{\rn}[1]{\text{\textsc{[#1]}}}
\newcommand{\mrule}[3]{%
      \multicolumn{6}{c}{
        \dfrac{
          \begin{array}{c}
            #2
          \end{array}
        }{#3}
      }
    &
      \rn{#1}
  \\
      \multicolumn{7}{c}{}
  \\%
}
\newcommand{\steprule}[5]{%
      \multicolumn{2}{l}{ #3 }
    &
      {#4}
    &
      \multicolumn{2}{l|}{ #5 }
    &
      #2
    &
      \rn{#1}
  \\%
}
\newcommand{\tsteparrow}[1]{\overset{#1}{\longrightarrow}}
\newcommand{\tstep}[3]{#2\tsteparrow{#1}#3}
\newcommand{\tsteprule}[5]{\steprule{#1}{#2}{#4}{\tsteparrow{#3}}{#5}}
\newcommand{\ssteparrow}[1]{\overset{#1}{\longrightarrow}}
\newcommand{\ssteparrowstar}[1]{\overset{#1}{\longrightarrow^*}}
\newcommand{\sstep}[3]{#2\ssteparrow{#1}#3}
\newcommand{\sstepstar}[3]{#2\ssteparrowstar{#1}#3}
\newcommand{\ssteprule}[5]{\steprule{#1}{#2}{#4}{\ssteparrow{#3}}{#5}}

\newcommand{\hole}{{\bullet}}
\newcommand{\hash}[2]{\##1\,{:}{=}\,#2}
\newcommand{\replace}[3]{\storeupdate{#1}{#2}{#3}}
\newcommand{\upd}[3]{\replace{#1}{#2}{#3}}
\newcommand{\ret}[1]{\text{\textsf{return}}#1}
\newcommand{\bindIO}[2]{%
  #1\,
  \overset{\text{\texttt{IO}}}
    {{>}\!\!{>}\!{=}}
  \,#2
  %
}
\newcommand{\bind}[2]{%
  #1\,
  \overset{\text{\texttt{FIO}}}
    {{>}\!\!{>}\!{=}}
  \,#2
  %
}
\newcommand{\newref}[1]{\text{\textsf{new}}#1}
\newcommand{\readref}[1]{\text{\textsf{read}}#1}
\newcommand{\writeref}[2]{\text{\textsf{write}}#1#2}
\newcommand{\Raw}[1]{\text{\textsf{Raw}}#1}
\newcommand{\bindFac}[2]{\text{\textsf{BindFac}}#1#2}
%\newcommand{\bindFac}[2]{%
%  #1\,
%  \overset{\text{\texttt{Fac}}}
%    {{>}\!\!{>}\!{=}}
%  \,#2
%  %
%}
\newcommand{\prodd}[1]{\text{\textsf{runFacFIO}}#1}
\newcommand{\threads}[3]{\,[\!\!\!\ffacet{#1}{#2}{#3}\!\!\!]\,}
\newcommand{\yield}[2]{\text{\textsf{yield}}#1#2}
\newcommand{\readfile}[1]{\text{\textsf{get}}#1}
\newcommand{\readfilen}[2]{\text{\textsf{get}}#1#2}
\newcommand{\writefile}[2]{\text{\textsf{put}}#1#2}
\newcommand{\readevent}[2]{\text{\textsf{R}}(#1,#2)}
\newcommand{\writeevent}[2]{\text{\textsf{W}}(#1,#2)}
\newcommand{\notbr}[1]{\overline{#1}}
\newcommand{\concat}[2]{#1\,{{+}\!\!{+}}\,#2}

\newcommand{\letrec}[3]{\mu x{:}T.t}
\newcommand{\ifPositive}[3]{\text{\textsf{ifPositive $#1$ $#2$ $#3$}}}
\newcommand{\IntType}{\text{\textsf{Int}}}
\newcommand{\FacetedType}[1]{\text{\textsf{Faceted}}#1}
\newcommand{\FIOType}[1]{\text{\textsf{FIO}}#1}
\newcommand{\FIORefType}[1]{\text{\textsf{FIORef}}#1}
\newcommand{\agree}[2]{#2\vdash#1}
\newcommand{\stdize}[1]{\s{standardize}{#1}}

\newcommand{\s}[1]{\text{\textit{#1}}}

\newcommand{\startsyntax}{\begin{array}{rclrll}}
\newcommand{\sepsyntax}{\\&&&|&}
\newcommand{\finishsyntax}{\end{array}}

\newcommand{\process}[2]{(#1,#2)}
\newcommand{\opread}[2]{\textsf{read}#1#2}
\newcommand{\opwrite}[3]{\textsf{write}#1#2#3}
\newcommand{\opsend}[3]{\textsf{send}#1#2#3}
\newcommand{\opfork}[2]{\textsf{fork}#1#2}
\newcommand{\opstuck}{\textsf{stuck}}
\newcommand{\opraiselabel}[2]{\textsf{raiseLabel}#1#2}
\newcommand{\evstart}[1]{\textsf{start}#1}
\newcommand{\evsend}[2]{\textsf{output}#1#2}
\newcommand{\proj}[2]{#1{\downarrow_{#2}}}
\newcommand{\lequiv}[3]{#2\approx_{#1}#3}


\begin{figure*}
$\startsyntax
  l     & \in & \s{Label}  \\
  ch    & \in & \s{Channel}  \\
  &           & \s{label} & : & \s{Channel}\to\s{Label}  \\
  v     & \in & \s{Value}  \\
  S     & \in & \s{LabeledValueSeq} & = & \multicolumn{2}{l}{(\s{Value}\times\s{Label})^*}  \\
  k     & \in & \s{Key}  \\
  \sigma& \in & \s{Store} & = & \s{Key}\to\s{LabeledValueSeq}  \\
  t     & \in & \s{Thread}  \\
  p     & \in & \s{Process} & ::= & \process{t}{l}  \\
  ps    & \in & \s{Processes} & = & \text{multisets of processes}  \\
  f     & \in & \s{ReadContinuation} & = & \s{LabeledValueSeq}\to\s{Thread}  \\
  op    & \in & \s{Operation} & ::= &
      \opread{k}{f}
    \sepsyntax
      \opwrite{k}{v}{t}
    \sepsyntax
      \opsend{ch}{v}{t}
    \sepsyntax
      \opfork{t}{t}
    \sepsyntax
      \opraiselabel{l}{t}
    \sepsyntax
      \opstuck
    \\
  e     & \in & \s{Event} & ::= &
      \evstart{p}
    \sepsyntax
      \evsend{ch}{v}
    \sepsyntax
      \epsilon
    \\
  es    & \in & \s{Events} & = & \s{Event}^*  \\
  \Sigma& \in & \s{State} & ::= & (\sigma,ps)  \\
  &           & \s{run} & : & \s{Thread}\to\s{Operation}  \\
  &           & \s{write} & : & \s{LabeledValueSeq}\times\s{Value}\times\s{Label}\to\s{LabeledValueSeq}  \\
  &           & \s{write}(S,v,l) & = & (S\setminus\{(v',l')\in S|l\sqsubseteq l'\})(v,l)  \\
  &           & \proj{\hole}{\hole}
                  & : & \text{``Various things''}\to\s{Label}\to\text{``Various things''}  \\
  &           & \proj{S}{l} & = & S\setminus\{(v',l')\in S|l'\not\sqsubseteq l\}  \\
  &           & \proj{ps}{l} & = & \text{multiset}\{\process{t}{l'}\in ps|l'\sqsubseteq l\}  \\
  &           & \proj{\sigma}{l} & = & \lambda k. \proj{\sigma(k)}{l}  \\
  &           & \proj{e}{l} & = &
    \begin{cases}
      e  & \exists t,l'.e=\evstart{\process{t}{l'}}\text{ and }l'\sqsubseteq l  \\
      e  & \exists ch,v.e=\evsend{ch}{v}\text{ and }\s{label}(ch)\sqsubseteq l  \\
      \epsilon & \text{otherwise.}
    \end{cases}  \\
  &           & \proj{(e_1\ldots e_n)}{l} & = & \proj{e_1}{l}\ldots\proj{e_n}{l}  \\
  &           & \proj{(\sigma,ps)}{l} & = & (\proj{\sigma}{l},\proj{ps}{l})   \\
  &           & \lequiv{l}{\hole_1}{\hole_2} & \text{means} & \proj{\hole_1}{l}=\proj{\hole_2}{l}  \\
\finishsyntax$
\end{figure*}

\begin{figure*}
\fbox{$\tstep{e}{(\sigma,p)}{\Sigma}$} Process transition relation
\\
$\startrules
  \tsteprule{p-send}
        {\s{run}(t)=\opsend{ch}{v}{t'}\qquad l\sqsubseteq\s{label}(ch)}
        {\evsend{ch}{v}}
        {(\sigma,\process{t}{l})}
        {(\sigma,\{\process{t'}{l}\})}
  \tsteprule{p-read}
        {\s{run}(t)=\opread{k}{f}}
        {\epsilon}
        {(\sigma,\process{t}{l})}
        {(\sigma,\{\process{f(\proj{\sigma(k)}{l})}{l}\})}
  \tsteprule{p-write}
        {\s{run}(t)=\opwrite{k}{v}{t'}}
        {\epsilon}
        {(\sigma,\process{t}{l})}
        {(\upd{\sigma}{k}{\s{write}(\sigma(k),v,l)},\{\process{t'}{l}\})}
  \tsteprule{p-fork}
        {\s{run}(t) = \opfork{t_1}{t_2}}
        {\epsilon}
        {(\sigma,\process{t}{l})}
        {(\sigma,\{\process{t_1}{l},\process{t_2}{l}\})}
  \tsteprule{p-raise-label}
        {\s{run}(t) = \opraiselabel{l'}{t'}\qquad l\sqsubseteq l'}
        {\epsilon}
        {(\sigma,\process{t}{l})}
        {(\sigma,\{\process{t'}{l'}\})}
\finishrules$
\\
\fbox{$\sstep{e}{\Sigma}{\Sigma}$} State transition relation
\\
$\startrules
  \ssteprule{s-start}
        {}
        {\evstart{p}}
        {(\sigma,ps)}
        {(\sigma,ps+p)}
  \ssteprule{s-skip}
        {}
        {\epsilon}
        {(\sigma,ps)}
        {(\sigma,ps)}
  \ssteprule{s-step}
        {\tstep{e}{(\sigma,\process{t}{l})}{(\sigma',ps')}}
        {e}
        {(\sigma,ps\uplus\{\process{t}{l}\})}
        {(\sigma',ps\uplus ps')}
\finishrules$
\end{figure*}

\textbf{Theorem (Single step Progress Sensitive Non-Interference).}
\\
If $\lequiv{l}{\Sigma_1}{\Sigma_2}$
and $\sstep{e_1}{\Sigma_1}{\Sigma_1'}$,
\\
then $\exists \Sigma_2'.\exists e_2.\sstep{e_2}{\Sigma_2}{\Sigma_2'}$
and $\lequiv{l}{\Sigma_1'}{\Sigma_2'}$
and $\lequiv{l}{e_1}{e_2}$.
\\
\textit{Proof.}
See appendix.
\\
\fbox{$\sstepstar{es}{\Sigma}{\Sigma}$} Multiple-step state transition relation
\\
$\startrules
  \mrule{refl}{
  }{
    \sstepstar{}{\Sigma}{\Sigma}
  }
  \mrule{trans}{
      \sstep{e}{\Sigma}{\Sigma'}
    \qquad
      \sstepstar{es}{\Sigma'}{\Sigma''}
  }{
    \sstepstar{ees}{\Sigma}{\Sigma''}
  }
\finishrules$
\\
\textbf{Corollary (Progress Sensitive Non-Interference).}
\\
If $\lequiv{l}{\Sigma_1}{\Sigma_2}$
and $\sstepstar{es_1}{\Sigma_1}{\Sigma_1'}$,
\\
then $\exists \Sigma_2'.\exists es_2.\sstepstar{es_2}{\Sigma_2}{\Sigma_2'}$
and $\lequiv{l}{\Sigma_1'}{\Sigma_2'}$
and $\lequiv{l}{es_1}{es_2}$.
\\
\textit{Proof.}
By induction on the derivation of $\sstepstar{es_1}{\Sigma_1}{\Sigma_1'}$.
