%\section{Semantics}

%Tables~\ref{ta:ifc-total} and~\ref{ta:ifc-partial} summarize the 
%proposed operational semantics for totally and parially ordered
%security labels respectively.

\begin{table*}
\[
\begin{array}{lclr}
\hline\hline
\semrule{\tuple{e,empty}}{w}{\tuple{e,e}}{\mbox{write to an empty cell in the data store}}\\
\hline
\semrule{\tuple{e,l}}{w}{\case{\mbox{error}}{\mbox{if} ~ e > l}{\tuple{e,e}}{\mbox{otherwise}}} {\mbox{write to a cell in the data store}}\\
\hline
\semrule{\tuple{e,empty}}{r}{\tuple{e,empty}, empty}{\mbox{read an empty cell in the data store}}\\
\hline
\semrule{\tuple{e,l}}{r}{\case{\tuple{max(e,l),l}, v}{\mbox{if} ~ m \geq l}{\tuple{e,l}, empty}{\mbox{otherwise}}} {\mbox{read a cell in the data store}}\\
\hline\hline
\end{array}
\]
\caption{\label{ta:ifc-total}%
Small-step operational semantics for enforcing IFC with a total order over the security labels. $m$ is a paramater of the program execution s.t. m is the maximal security label allowed for the execution.}
\end{table*}

\begin{table*}
\[
\begin{array}{lclr}
\hline\hline
\semrule{\tuple{e,\emptyset}}{w(v)}{\tuple{e,\{\tuple{v,e}\}}}{\mbox{write to an empty cell in the data store}}\\
\hline
\semrule{\tuple{e,S}}
        {w(v)}
        {\case{\mbox{error}}
              {\exists \tuple{v',l'} \in S. ~ l' < e}
              {\tuple{e,(S \setminus \{\tuple{v',l'} | l' \geq e \}) \cup \{\tuple{v,e}\}}}
              {\mbox{otherwise}}}
        {\mbox{write to a cell in the data store}}\\
\hline
\semrule{\tuple{e,\emptyset}} {r} {\tuple{e,\emptyset}, empty} {\mbox{read an empty cell in the data store}}\\
\hline
\multicolumn{4} {l} {\mbox{let}~ S\!\downarrow_m = \{\tuple{v,l}\in S | l \leq m\} }\\
\semrule{\tuple{e,S}}
        {r}
        {\casethree{\tuple{e,S}, empty} {|S\!\downarrow_m| = 0}
                   {\tuple{max(e,l), S}, v} {|S\!\downarrow_m| = 1}
                   {\mbox{error}}{|S\!\downarrow_m| > 1}}
        {\mbox{read a cell in the data store}}\\
\hline\hline
\end{array}
\]
\caption{\label{ta:ifc-partial}%
Small-step operational semantics for enforcing IFC with a partial order over the security labels. $m$ is a paramater of the program execution s.t. m is the maximal security label allowed for the execution.}
\end{table*}

\section{Discussion}

While faceting prevents leaking of information through termination, it 
also changes the semantics of the data store expected by the 
application.  However this should not occur during normal operation.  
Creation of multiple facets indicates an attempted security violation 
and is signaled to the administrator. While the issue is being 
resolved, faceting continues to enforce confidentiality.

%We employ two techniques to enforce confidentiality at the data-store
%level: (1) faceting and (2) the no-sensitive-upgrade (NSU) rule.  The former
%restricts information flow by presenting different views of the store
%to different observers.  We use it to isolate writes by incomparable 
%users.  The latter prevents the flow of information down the lattice by
%blocking high writes to low locations.  Both mechanisms preserve
%termination sensitivity.  NSU reduces faceting (which can be seen as a
%form of store corruption that requires manual intervention) by
%sacrificing transparency.  Without NSU, we would need to introduce
%facets for each label, not just incomparable ones.

\section{Properties of the Semantics}

Below we state some properties of our proposed scheme which need to be verified w.r.t.
a formal semantics of executions.

\begin{conj}
Our semantics enforces termination-sensitive noninterference, i.e., whenever there exists
a way to violate the information flow requirement, it enforces noninterference by either yielding an error (the no-sensitive-upgrade case)
or faceting the data store (the incomparable writes case).
\end{conj}

\begin{conj}
Our semantics can be easily implemented for Javascript programs using
any key value DB with very low runtime overhead.
\end{conj}

\begin{conj}
Our semantics can identify interesting bugs in real applications.
\end{conj}

\begin{conj}
Our semantics is not transparent, i.e., there exist correct programs for which our semantics
will yield error.
\end{conj}

\begin{conj}
In practical serverless applications, the no-sensitive-upgrade semantics is preferable to transparency
as it avoids data store corruption.
\end{conj}

\begin{conj}
Correct programs which are rejected by our semantics can be modified to work with our IFC model with modest implementation effort.
\end{conj}

%\section{Partial Order}
