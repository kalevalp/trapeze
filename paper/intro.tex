\section{Introduction} % (fold)
\label{sec:introduction}

We have come to entrust the cloud with all our digital assets, including identity records, financial information, health records, etc. Numerous recent high-profile cloud exploits, leaking millions of user records at a time, indicate that this trust is misplaced. In this project we focus on the problem of protecting confidential user data stored in the cloud from unauthorized access. In particular, we set out to explore the security implications of serverless computing. In the serverless model, users express their applications as collections of functions with the following properties:

\begin{itemize}
    \item A function can be written in any language; in particular, a single serverless application may contain functions written in multiple languages.

    \item A function expects a certain runtime environment, defined by its developer, including, e.g., specific versions of the Python interpreter and libraries, database connections, etc., but is agnostic of where this environment is instantiated (physical machine/VM/container, etc.)

    \item A function can be triggered by (1) an external event, e.g., user request, (2) a data store update, or (3) another function.

    \item Each invocation of a function starts from a clean state. In particular, no state can be reused across multiple concurrent or sequential invocations of the function. Functions can only exchange data via a shared data store or via arguments to invocations. This design is meant to enable elastic scalability, however we believe that it also has fundamental implications for security.

\end{itemize}


The transition to the serverless model further complicates the cloud ecosystem, potentially making it even harder to keep the cloud secure. At the same time it also presents an interesting opportunity, enabling new kinds of security mechanisms that are not easily applicable in the traditional server-based architecture.

Specifically, we take the information flow control (IFC) approach to security. In contrast to other security models, e.g., ones based on capabilities, access control lists, or microsegmentation, IFC supports first-class abstractions for specifying and enforcing information security.

IFC is hard to implement efficiently in the traditional server-based model, where a server handles requests from multiple, potentially concurrent, users. Precise information flow analysis in these settings requires tracking the flow of sensitive data at the level of individual instructions or program statements. In contrast, a serverless function is invoked to perform a single operation on behalf of a specific user, and only accesses data related to the given user and the given operation. Furthermore, each activation starts from a clean state and does not get polluted with sensitive data from other activations. This suggests that it might be possible to create an accurate and efficient dynamic information flow control mechanism for serverless applications that operates at the granularity of functions rather than program statements.

Our proposed mechanism treats a serverless function as a black box that can potentially propagate any of its input data to any of its outputs. Whenever the function obtains sensitive data, either as an input or by reading it from the data store, it becomes tainted with the security label derived from this data. All

outputs generated by the current activation of the function after this point in its execution, including writes to the data store and calls to other serverless functions, carry the same label. The secure runtime enforces that a function can only send data to an external output channel when its current security label is weaker than the label attached to the channel.

This approach can be implemented in a language-agnostic manner, with low runtime overhead and minimal or no modifications to application code. It requires adding a security shim to each function instance, responsible for:

\begin{enumerate}
    \item tracking the security label of the function
    \item propagating the label via function invocations
    \item checking the label before sending to an external channel
    \item mediating access to the data store, which involves
    \begin{itemize}
        \item attaching security label to each record written to the store
        \item updating the security label of the function when reading a record from the store
    \end{itemize}
\end{enumerate}

Note that our proposed solution is not meant to replace existing security mechanism. Rather, it creates a safety net around the application that prevents information leaks when other security mechanisms have been compromised.
% section introduction (end)