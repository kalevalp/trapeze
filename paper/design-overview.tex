\section{Design Overview}

We are considering two alternative IFC algorithms.  The first one 
directly applies the standard progress-insensitive IFC from the 
literature in the serverless setting outlined in the previous section.  
The second one achieves progress sensitivity by introducing a faceted 
data store and assigning a maximal security label to each user 
request.

\subsection{Design 1}

Recall that a function can be triggered by (1) an external event, 
e.g., user request, (2) a data store update, or (3) another lambda.

\begin{itemize}
    \item We associate an effective security label $e$ with each 
        function activation.

    \item The effective label is initially set to the confidentiality 
        level of the source that triggered the activation (user's 
        security label in case (1) above, the security label of the 
        database update in case (2), or the effective security label 
        of the caller in case (3)).

    \item The effective label increases monotonically during execution 
        of the function as it reads confidential values from the data 
        store.

    \item The function can perform two types of I/O actions: (1) send 
        a message to an external output channel (e.g., the end-user 
        HTTP session) and (2) read or write the data store.  Both 
        actions are restricted by the following rules:

        \begin{itemize}
            \item The send operation is only allowed if the security 
                label of the output channel is greater than or equal 
                to $e$. Otherwise the send operation fails and the 
                function terminates.

            \item Consider a data store location that contains value v 
                with label $l$.  The activation can:
                \begin{itemize}
                    \item Read $v$. The effective label is set to the 
                        least upper bound of $e$ and $l$.

                    \item Write $v$ if $e \leq l$. The effective label 
                        does not change. The store location inherits 
                        label $e$.  The write operation fails 
                        otherwise, terminating execution of the 
                        function (the no-sensitive-upgrade rule).
                \end{itemize}
        \end{itemize}
\end{itemize}

One problem with this design is that it leaks information whenever a 
send or write operation fails.  In the serverless setting, where a 
single request can spawn any number of concurrent functions, unbounded 
amount of information can leak in this way through a single request.

\subsection{Design 2}

We therefore consider an alternative design that attempts to eliminate 
this channel. The key idea is to statically assign a maximal security 
label to each user request and modify the data store behavior to 
conceal the presence of any data with higher security labels.

\begin{itemize}
    \item We associate two security labels with an activation: an 
        effective label $e$ and the maximal label $m$.

    \item As before, the effective label is initially set to the 
        confidentiality level of the source that triggered the 
        activation.

    \item The effective label increases monotonically during execution 
        of the function as it reads confidential values from the data 
        store.

    \item Our secure runtime ensures that the effective label may not 
        exceed the maximal label ($e \leq m$).

    \item The maximal label is assigned by the secure runtime when the 
        function is being triggered by the user or by a data store 
        update and is inherited from the caller when the function is 
        invoked by another function. It must be greater than or equal 
        to the initial value of the effective label.  Importantly, 
        when the label is assigned by the runtime, its value must not 
        depend on any secret data above the initial effective label 
        (i.e., the confidentiality level of $m$ is $\leq e$).

    \item The function can perform two types of I/O actions: (1) send 
        a message to an external output channel (e.g., the end-user 
        HTTP session) and (2) read or write the data store.  Both 
        actions are restricted by the following rules, which 
        (hopefully) enforce confidentiality:

        \begin{itemize}
            \item The security label of the output channel must be 
                greater than or equal to the maximal security label of 
                the activation.  Note that using the maximal security 
                label, rather than the effective one, is essential to 
                preventing information leaks.

            \item Consider an activation with effective and maximal 
                labels $e$ and $m$ respectively and a data store 
                location that contains value $v$ with label $l$.  Our 
                secure data store semantics \emph{conceals} the 
                existence of any data whose confidentiality level is 
                higher than or incomparable to $m$ ($l \nleq m$).  
                
                We first consider the simple case where security 
                labels form a total order. The corresponding data 
                store semantics is given in Table~\ref{ta:ifc-total}, 
                with the write operation specified as 
                $\semruletxt{\tuple{e,l}}{w}{\tuple{e',l'}}$, and the 
                read operation specified as 
                $\semruletxt{\tuple{e,l}}{r}{\tuple{e',l'}, v'}$, 
                where $e$ and $l$ are the effective security label of 
                the function and the security label of the data store 
                location before the operation; $e'$ and $l'$ are the 
                new security labels after the operation, $m$ is the 
                maximal security label of the function, and $v'$ is 
                the value returned by the read operation, or the 
                special $empty$ value.

                Intuitively, the write operation overwrites the data 
                store location with the new value and security label, 
                unless the data store contains a less secret label, in 
                which case the write fails (enforcing the the 
                no-sensitive-upgrade policy).  A read returns the 
                value in the data store, tainting the function with 
                its label, unless the data store location has 
                confidentiality label $l>m$, in which case the $empty$ 
                value is returned.  
        
            \item We now consider the general case where security 
                labels form a lattice.  Table~\ref{ta:ifc-partial} 
                gives the operational semantics in this case.  

                We introduce faceted data store, where each location 
                contains a set of values with incomparable security 
                labels.  The write behavior depends on whether there 
                exists a facet with a comparable label in the data 
                store.  If a comparable facet exists, the write will 
                either overwrite its value or fail if the data store 
                label is lower than $e$ (no sensitive upgrade).  
                Otherwise, a new facet is created.  

                The read operation returns $empty$ if no facet whose 
                label $l$ is $\leq m$ exists in the data store; 
                alternatively is a unique such facet exists, it 
                returns the value in that facet; finally, if more than 
                one such face exists in the data store, an error is 
                returned.
        \end{itemize}
\end{itemize}